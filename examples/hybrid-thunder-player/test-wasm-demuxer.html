<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æµ‹è¯• Thunder WASM Demuxer (packetè¾“å‡º)</title>
  <style>
    body {
      font-family: monospace;
      padding: 20px;
      background: #1e1e1e;
      color: #d4d4d4;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      color: #4ec9b0;
    }
    .status {
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      background: #2d2d30;
    }
    .success { color: #4ec9b0; }
    .error { color: #f48771; }
    .warning { color: #dcdcaa; }
    button {
      padding: 10px 20px;
      margin: 5px;
      background: #0e639c;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #1177bb;
    }
    #log {
      background: #1e1e1e;
      border: 1px solid #3c3c3c;
      padding: 15px;
      height: 400px;
      overflow-y: auto;
      font-size: 12px;
      margin-top: 20px;
    }
    .log-entry {
      margin: 2px 0;
      padding: 2px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ”¬ Thunder WASM Demuxer æµ‹è¯•</h1>
    <p>æµ‹è¯• Thunderè§£å¯†+FFmpeg demux â†’ packetè¾“å‡º</p>

    <div class="status">
      <div>WASMæ¨¡å—: <span id="wasmStatus" class="warning">æœªåŠ è½½</span></div>
      <div>DecoderçŠ¶æ€: <span id="decoderStatus" class="warning">æœªåˆå§‹åŒ–</span></div>
      <div>Packetå›è°ƒ: <span id="callbackStatus" class="warning">æœªè®¾ç½®</span></div>
    </div>

    <div>
      <button onclick="checkFunctions()">1. æ£€æŸ¥å¯¼å‡ºå‡½æ•°</button>
      <button onclick="setupCallback()">2. è®¾ç½®Packetå›è°ƒ</button>
      <button onclick="initDecoder()">3. åˆå§‹åŒ–Decoder</button>
      <button onclick="readPackets(5)">4. è¯»å–5ä¸ªPackets</button>
      <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
    </div>

    <div id="log"></div>
  </div>

  <!-- åŠ è½½æ–°ç¼–è¯‘çš„Thunder WASMæ¨¡å— -->
  <script>
    // WASMæ¨¡å—åŠ è½½å›è°ƒ
    var Module = {
      onRuntimeInitialized: function() {
        log('âœ… WASMæ¨¡å—åŠ è½½å®Œæˆ', 'success');
        document.getElementById('wasmStatus').textContent = 'å·²åŠ è½½';
        document.getElementById('wasmStatus').className = 'success';
      }
    };
  </script>
  <script src="./thunder_module.js"></script>

  <script>
    let packetCallback = null;
    let packetCount = 0;

    function log(message, type = 'info') {
      const logDiv = document.getElementById('log');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
      logDiv.appendChild(entry);
      logDiv.scrollTop = logDiv.scrollHeight;
      console.log(message);
    }

    function clearLog() {
      document.getElementById('log').innerHTML = '';
    }

    // 1. æ£€æŸ¥å¯¼å‡ºå‡½æ•°
    function checkFunctions() {
      log('ğŸ” æ£€æŸ¥å¯¼å‡ºå‡½æ•°...', 'warning');

      const functions = [
        '_js_init_auth',
        '_js_get_version',
        '_initDecoder',
        '_openDecoder',
        '_sendData',
        '_decodeOnePacket',
        '_js_setPacketCallback',
        '_js_readOnePacket',
        '_setPacketCallback',
        '_readOnePacket'
      ];

      let missingCount = 0;
      functions.forEach(fn => {
        if (typeof Module[fn] === 'function') {
          log(`  âœ… ${fn}: å·²å¯¼å‡º`, 'success');
        } else {
          log(`  âŒ ${fn}: æœªå¯¼å‡º`, 'error');
          missingCount++;
        }
      });

      if (missingCount === 0) {
        log('âœ… æ‰€æœ‰å‡½æ•°æ£€æŸ¥é€šè¿‡ï¼', 'success');
      } else {
        log(`âŒ æœ‰ ${missingCount} ä¸ªå‡½æ•°æœªå¯¼å‡º`, 'error');
      }
    }

    // 2. è®¾ç½®Packetå›è°ƒ
    function setupCallback() {
      log('ğŸ”§ è®¾ç½®Packetå›è°ƒ...', 'warning');

      if (typeof Module._js_setPacketCallback !== 'function') {
        log('âŒ _js_setPacketCallback æœªå¯¼å‡º', 'error');
        return;
      }

      try {
        packetCallback = Module.addFunction(
          function(stream_type, dataPtr, size, pts, dts, flags) {
            packetCount++;
            const streamName = stream_type === 0 ? 'VIDEO' : 'AUDIO';
            const isKeyframe = (flags & 1) !== 0;

            log(`ğŸ“¦ Packet #${packetCount}: ${streamName} ${size}B, pts=${pts}, keyframe=${isKeyframe}`, 'success');

            // è¯»å–å‰16å­—èŠ‚
            const data = new Uint8Array(Module.HEAPU8.buffer, dataPtr, Math.min(16, size));
            const hex = Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
            log(`   æ•°æ®: ${hex}`, 'info');

            // H264 NALåˆ†æ
            if (stream_type === 0 && size >= 5) {
              if (data[0] === 0 && data[1] === 0 && data[2] === 0 && data[3] === 1) {
                const nalType = data[4] & 0x1F;
                const nalNames = { 1: 'Non-IDR', 5: 'IDR', 6: 'SEI', 7: 'SPS', 8: 'PPS', 9: 'AU delimiter' };
                log(`   H264 NALç±»å‹: ${nalType} (${nalNames[nalType] || 'å…¶ä»–'})`, 'success');
              }
            }
          },
          'viiiiii'
        );

        Module._js_setPacketCallback(packetCallback);
        log('âœ… Packetå›è°ƒè®¾ç½®æˆåŠŸ', 'success');
        document.getElementById('callbackStatus').textContent = 'å·²è®¾ç½®';
        document.getElementById('callbackStatus').className = 'success';
      } catch (e) {
        log('âŒ è®¾ç½®å›è°ƒå¤±è´¥: ' + e.message, 'error');
      }
    }

    // 3. åˆå§‹åŒ–Decoder
    function initDecoder() {
      log('ğŸ”§ åˆå§‹åŒ–Decoder...', 'warning');

      if (typeof Module._initDecoder !== 'function') {
        log('âŒ _initDecoder æœªå¯¼å‡º', 'error');
        return;
      }

      try {
        const fileSize = 100 * 1024 * 1024; // 100MB
        const result = Module._initDecoder(fileSize, 0);

        if (result === 0) {
          log('âœ… Decoderåˆå§‹åŒ–æˆåŠŸ', 'success');
          document.getElementById('decoderStatus').textContent = 'å·²åˆå§‹åŒ–';
          document.getElementById('decoderStatus').className = 'success';
        } else {
          log(`âŒ Decoderåˆå§‹åŒ–å¤±è´¥: ${result}`, 'error');
        }
      } catch (e) {
        log('âŒ åˆå§‹åŒ–å¤±è´¥: ' + e.message, 'error');
      }
    }

    // 4. è¯»å–Packets
    function readPackets(count) {
      log(`ğŸ“– å¼€å§‹è¯»å– ${count} ä¸ªpackets...`, 'warning');

      if (typeof Module._js_readOnePacket !== 'function') {
        log('âŒ _js_readOnePacket æœªå¯¼å‡º', 'error');
        return;
      }

      if (!packetCallback) {
        log('âš ï¸ è­¦å‘Šï¼šPacketå›è°ƒæœªè®¾ç½®ï¼Œå°†ä¸ä¼šæ˜¾ç¤ºpacketå†…å®¹', 'warning');
      }

      let successCount = 0;
      let errorCount = 0;

      for (let i = 0; i < count; i++) {
        try {
          const result = Module._js_readOnePacket();
          if (result === 0) {
            successCount++;
          } else {
            errorCount++;
            if (errorCount === 1) {
              log(`âš ï¸ readOnePacketè¿”å›: ${result} (EOFæˆ–æ— æ•°æ®)`, 'warning');
            }
          }
        } catch (e) {
          log(`âŒ è¯»å–å¤±è´¥: ${e.message}`, 'error');
          errorCount++;
        }
      }

      log(`âœ… è¯»å–å®Œæˆ: æˆåŠŸ${successCount}, é”™è¯¯${errorCount}`, successCount > 0 ? 'success' : 'warning');
    }

    // é¡µé¢åŠ è½½å®Œæˆ
    window.onload = function() {
      log('ğŸš€ é¡µé¢åŠ è½½å®Œæˆï¼Œè¯·æŒ‰é¡ºåºç‚¹å‡»æŒ‰é’®æµ‹è¯•', 'info');
      log('âš ï¸ æ³¨æ„ï¼šéœ€è¦å…ˆæœ‰è§†é¢‘æ•°æ®æ‰èƒ½è¯»å–packets', 'warning');
    };
  </script>
</body>
</html>
